{
  "schemaVersion": "0.3", 
  "description": "Creates a Linux Managed Instance with approval", 
  "assumeRole": "{{AutomationAssumeRole}}", 
  "parameters": {
    "AmiId": {
      "type": "String", 
      "description": "(Required) AMI id to use for launching the instance.", 
      "default": ""
    }, 
    "VpcId": {
      "type": "String", 
      "description": "(Required) New instance will be deployed into this vpc or in the default vpc if not specified.", 
      "default": "Default"
    }, 
    "RoleName": {
      "type": "String", 
      "description": "(Required) Role Name to create.", 
      "default": "SSMManagedInstanceProfileRole"
    }, 
    "GroupName": {
      "type": "String", 
      "description": "(Required) Security Group Name to create.", 
      "default": "SSMSecurityGroupForLinuxInstances"
    }, 
    "InstanceType": {
      "type": "String", 
      "description": "(Required) Type of instance to launch. Default is t2.medium.", 
      "default": "t2.medium"
    }, 
    "KeyPairName": {
      "type": "String", 
      "description": "(Required) Key pair to use when creating instance."
    }, 
    "RemoteAccessCidr": {
      "type": "String", 
      "description": "(Required) Creates Security group with port for SSH(Port range 22) open to IPs specified by CIDR (default is 0.0.0.0/0). If the security group already exists it will not be modified and rules will not be changed.", 
      "default": "0.0.0.0/0"
    }, 
    "Approvers": {
      "type": "StringList", 
      "description": "(Required) IAM user or user arn of approvers for the automation action"
    }, 
    "SNSTopicArn": {
      "type": "String", 
      "description": "(Required) The SNS topic ARN used to send pending approval notification for creating a new managed instance. The SNS topic name must start with Automation."
    }, 
    "StackName": {
      "type": "String", 
      "description": "(Optional) Specify stack name used by this document", 
      "default": "CreateManagedInstanceStack{{automation:EXECUTION_ID}}"
    }, 
    "AutomationAssumeRole": {
      "type": "String", 
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf", 
      "default": ""
    }, 
    "SubnetId": {
      "type": "String", 
      "description": "(Required) New instance will be deployed into this subnet or in the default subnet if not specified.", 
      "default": "Default"
    }
  }, 
  "mainSteps": [
    {
      "action": "aws:approve", 
      "inputs": {
        "NotificationArn": "{{SNSTopicArn}}", 
        "Message": "Approval required to create a managed instance", 
        "Approvers": "{{Approvers}}", 
        "MinRequiredApprovals": 1
      }, 
      "name": "approve", 
      "onFailure": "Abort"
    }, 
    {
      "name": "createManagedInstanceStack", 
      "action": "aws:createStack", 
      "maxAttempts": 1, 
      "onFailure": "Abort", 
      "inputs": {
        "OnFailure": "ROLLBACK", 
        "Capabilities": [
          "CAPABILITY_IAM"
        ], 
        "Parameters": [
          {
            "ParameterKey": "AmiId", 
            "ParameterValue": "{{AmiId}}"
          }, 
          {
            "ParameterKey": "InstanceType", 
            "ParameterValue": "{{InstanceType}}"
          }, 
          {
            "ParameterKey": "RoleName", 
            "ParameterValue": "{{RoleName}}"
          }, 
          {
            "ParameterKey": "GroupName", 
            "ParameterValue": "{{GroupName}}"
          }, 
          {
            "ParameterKey": "VpcId", 
            "ParameterValue": "{{VpcId}}"
          }, 
          {
            "ParameterKey": "SubnetId", 
            "ParameterValue": "{{SubnetId}}"
          }, 
          {
            "ParameterKey": "LambdaRoleArn", 
            "ParameterValue": "{{AutomationAssumeRole}}"
          }, 
          {
            "ParameterKey": "KeyName", 
            "ParameterValue": "{{KeyPairName}}"
          }, 
          {
            "ParameterKey": "RemoteAccessCidr", 
            "ParameterValue": "{{RemoteAccessCidr}}"
          }
        ], 
        "StackName": "{{StackName}}", 
        "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nConditions:\n  IsVerbose:\n    Fn::Equals:\n    - {Ref: Verbose}\n    - 'true'\n  IsVerboseAndLambdaRoleNotSpecified:\n    Fn::And:\n    - {Condition: LambdaAssumeRoleNotSpecified}\n    - {Condition: IsVerbose}\n  KeyNameSpecified:\n    Fn::And:\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: KeyName}\n        - ''\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: KeyName}\n        - undefined\n  LambdaAssumeRoleNotSpecified:\n    Fn::Or:\n    - Fn::Equals:\n      - {Ref: LambdaRoleArn}\n      - ''\n    - Fn::Equals:\n      - {Ref: LambdaRoleArn}\n      - undefined\n  RemoteAccessSpecified:\n    Fn::And:\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: RemoteAccessCidr}\n        - ''\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: RemoteAccessCidr}\n        - undefined\nParameters:\n  AmiId: {Description: AMI ID to be deploy., Type: String}\n  GroupName: {Description: (Required) Security Group Name to use or create if it does\n      not exists., Type: String}\n  InstanceType: {Description: Instance Type to deploy., Type: String}\n  KeyName: {Default: '', Description: Name of an existing EC2-VPC KeyPair, Type: String}\n  LambdaRoleArn: {Default: '', Description: 'Assume role used by the lambda function.\n      If not specified this template will create a temporarily role to be used by\n      the lambda created in this template.\n\n      ', Type: String}\n  RemoteAccessCidr: {Default: '', Description: 'CIDR block allowed access to SSH or\n      RDP to the instance that is deployed. Only added to ingress if a new security\n      group is created.\n\n      ', Type: String}\n  RoleName: {Description: (Required) Role name to use or create if it does not exists.,\n    Type: String}\n  SubnetId: {Description: Subnet to deploy the instance in., Type: String}\n  Verbose:\n    AllowedValues: ['true', 'false']\n    Default: 'true'\n    Description: 'Verbose setting\n\n      '\n    Type: String\n  VpcId: {Description: VPC to deploy the instance in., Type: String}\nResources:\n  CollectInformation:\n    Properties:\n      AmiId: {Ref: AmiId}\n      ServiceToken:\n        Fn::GetAtt: [CollectInformationLambda, Arn]\n      VpcId: {Ref: VpcId}\n    Type: Custom::CollectInformation\n  CollectInformationLambda:\n    Properties:\n      Code: {ZipFile: \"import boto3\\nimport traceback\\n\\nimport cfnresponse\\n\\n\\n\\\n          def handler_ami_info(event, context):\\n\\ttry:\\n\\t\\tec2 = boto3.client('ec2')\\n\\\n          \\t\\tami_id = event[\\\"ResourceProperties\\\"].get(\\\"AmiId\\\", None)\\n\\t\\tvpc_id\\\n          \\ = event[\\\"ResourceProperties\\\"].get(\\\"VpcId\\\", \\\"\\\")\\n\\t\\tif ami_id is\\\n          \\ None:\\n\\t\\t\\traise Exception(\\\"AMI id must be provided\\\")\\n\\n\\t\\tdata\\\n          \\ = {}\\n\\n\\t\\t# find platform based on ami\\n\\t\\timages = ec2.describe_images(ImageIds=[ami_id])[\\\"\\\n          Images\\\"]\\n\\t\\tif len(images) == 0:\\n\\t\\t\\traise Exception(\\\"No image found\\\n          \\ with \\\" + ami_id)\\n\\t\\tdata[\\\"Platform\\\"] = images[0].get(\\\"Platform\\\"\\\n          , \\\"linux\\\")\\n\\t\\tdata[\\\"UserData\\\"] = \\\"\\\" if data[\\\"Platform\\\"] == \\\"\\\n          windows\\\" else \\\"IyEvYmluL2Jhc2gNCg0KZnVuY3Rpb24gZ2V0X2NvbnRlbnRzKCkgew0KICAgIGlmIFsgLXggIiQod2hpY2ggY3VybCkiIF07IHRoZW4NCiAgICAgICAgY3VybCAtcyAtZiAiJDEiDQogICAgZWxpZiBbIC14ICIkKHdoaWNoIHdnZXQpIiBdOyB0aGVuDQogICAgICAgIHdnZXQgIiQxIiAtTyAtDQogICAgZWxzZQ0KICAgICAgICBkaWUgIk5vIGRvd25sb2FkIHV0aWxpdHkgKGN1cmwsIHdnZXQpIg0KICAgIGZpDQp9DQoNCnJlYWRvbmx5IElERU5USVRZX1VSTD0iaHR0cDovLzE2OS4yNTQuMTY5LjI1NC8yMDE2LTA2LTMwL2R5bmFtaWMvaW5zdGFuY2UtaWRlbnRpdHkvZG9jdW1lbnQvIg0KcmVhZG9ubHkgVFJVRV9SRUdJT049JChnZXRfY29udGVudHMgIiRJREVOVElUWV9VUkwiIHwgYXdrIC1GXCIgJy9yZWdpb24vIHsgcHJpbnQgJDQgfScpDQpyZWFkb25seSBERUZBVUxUX1JFR0lPTj0idXMtZWFzdC0xIg0KcmVhZG9ubHkgUkVHSU9OPSIke1RSVUVfUkVHSU9OOi0kREVGQVVMVF9SRUdJT059Ig0KDQpyZWFkb25seSBTQ1JJUFRfTkFNRT0iYXdzLWluc3RhbGwtc3NtLWFnZW50Ig0KIFNDUklQVF9VUkw9Imh0dHBzOi8vYXdzLXNzbS1kb3dubG9hZHMtJFJFR0lPTi5zMy5hbWF6b25hd3MuY29tL3NjcmlwdHMvJFNDUklQVF9OQU1FIg0KDQppZiBbICIkUkVHSU9OIiA9ICJjbi1ub3J0aC0xIiBdOyB0aGVuDQogIFNDUklQVF9VUkw9Imh0dHBzOi8vYXdzLXNzbS1kb3dubG9hZHMtJFJFR0lPTi5zMy5jbi1ub3J0aC0xLmFtYXpvbmF3cy5jb20uY24vc2NyaXB0cy8kU0NSSVBUX05BTUUiDQpmaQ0KDQppZiBbICIkUkVHSU9OIiA9ICJ1cy1nb3Ytd2VzdC0xIiBdOyB0aGVuDQogIFNDUklQVF9VUkw9Imh0dHBzOi8vYXdzLXNzbS1kb3dubG9hZHMtJFJFR0lPTi5zMy11cy1nb3Ytd2VzdC0xLmFtYXpvbmF3cy5jb20vc2NyaXB0cy8kU0NSSVBUX05BTUUiDQpmaQ0KDQpjZCAvdG1wDQpGSUxFX1NJWkU9MA0KTUFYX1JFVFJZX0NPVU5UPTMNClJFVFJZX0NPVU5UPTANCg0Kd2hpbGUgWyAkUkVUUllfQ09VTlQgLWx0ICRNQVhfUkVUUllfQ09VTlQgXSA7IGRvDQogIGVjaG8gQVdTLVVwZGF0ZUxpbnV4QW1pOiBEb3dubG9hZGluZyBzY3JpcHQgZnJvbSAkU0NSSVBUX1VSTA0KICBnZXRfY29udGVudHMgIiRTQ1JJUFRfVVJMIiA+ICIkU0NSSVBUX05BTUUiDQogIEZJTEVfU0laRT0kKGR1IC1rIC90bXAvJFNDUklQVF9OQU1FIHwgY3V0IC1mMSkNCiAgZWNobyBBV1MtVXBkYXRlTGludXhBbWk6IEZpbmlzaGVkIGRvd25sb2FkaW5nIHNjcmlwdCwgc2l6ZTogJEZJTEVfU0laRQ0KICBpZiBbICRGSUxFX1NJWkUgLWd0IDAgXTsgdGhlbg0KICAgIGJyZWFrDQogIGVsc2UNCiAgICBpZiBbWyAkUkVUUllfQ09VTlQgLWx0IE1BWF9SRVRSWV9DT1VOVCBdXTsgdGhlbg0KICAgICAgUkVUUllfQ09VTlQ9JCgoUkVUUllfQ09VTlQrMSkpOw0KICAgICAgZWNobyBBV1MtVXBkYXRlTGludXhBbWk6IEZpbGVTaXplIGlzIDAsIHJldHJ5Q291bnQ6ICRSRVRSWV9DT1VOVA0KICAgIGZpDQogIGZpIA0KZG9uZQ0KDQppZiBbICRGSUxFX1NJWkUgLWd0IDAgXTsgdGhlbg0KICBjaG1vZCAreCAiJFNDUklQVF9OQU1FIg0KICBlY2hvIEFXUy1VcGRhdGVMaW51eEFtaTogUnVubmluZyBVcGRhdGVTU01BZ2VudCBzY3JpcHQgbm93IC4uLi4NCiAgLi8iJFNDUklQVF9OQU1FIiAtLXJlZ2lvbiAiJFJFR0lPTiINCmVsc2UNCiAgZWNobyBBV1MtVXBkYXRlTGludXhBbWk6IFVuYWJsZSB0byBkb3dubG9hZCBzY3JpcHQsIHF1aXR0aW5nIC4uLi4NCmZp\\\"\\\n          \\n\\n\\t\\t# find default vpc id if non is specified\\n\\t\\tif len(vpc_id) ==\\\n          \\ 0 or vpc_id == \\\"Default\\\":\\n\\t\\t\\tvpc_id = \\\"\\\"\\n\\t\\t\\tfor vpc in ec2.describe_vpcs().get('Vpcs',\\\n          \\ []):\\n\\t\\t\\t\\tif vpc.get('IsDefault', False):\\n\\t\\t\\t\\t\\tvpc_id = vpc['VpcId']\\n\\\n          \\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif len(vpc_id) == 0:\\n\\t\\t\\t\\traise Exception(\\\"\\\n          Unable to find default vpc\\\")\\n\\t\\tdata[\\\"VpcId\\\"] = vpc_id\\n\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.SUCCESS, data, event.get(\\\"PhysicalResourceId\\\",\\\n          \\ None))\\n\\texcept Exception as e:\\n\\t\\tprint str(e)\\n\\t\\ttraceback.print_exc()\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, event.get(\\\"\\\n          PhysicalResourceId\\\", None))\\n\\n\\ndef handler_delete(event, context):\\n\\t\\\n          # Nothing to do... this is a informational lambda and no resource is created.\\n\\\n          \\tcfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event[\\\"PhysicalResourceId\\\"\\\n          ])\\n\\n\\ndef handler(event, context):\\n\\tif event[\\\"RequestType\\\"] in [\\\"\\\n          Create\\\", \\\"Update\\\"]:\\n\\t\\thandler_ami_info(event, context)\\n\\telif event[\\\"\\\n          RequestType\\\"] in [\\\"Delete\\\"]:\\n\\t\\thandler_delete(event, context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python2.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n  CollectSubnetInfoLambda:\n    Properties:\n      Code: {ZipFile: \"import boto3\\nimport traceback\\n\\nimport cfnresponse\\n\\n\\n\\\n          def handler_subnet_info(event, context):\\n\\ttry:\\n\\t\\tec2 = boto3.client('ec2')\\n\\\n          \\t\\tvpc_id = event[\\\"ResourceProperties\\\"].get(\\\"VpcId\\\", \\\"\\\")\\n\\t\\tsubnet_id\\\n          \\ = event[\\\"ResourceProperties\\\"].get(\\\"SubnetId\\\", \\\"\\\")\\n\\n\\t\\tdata =\\\n          \\ {}\\n\\n\\t\\tif len(subnet_id) == 0 or subnet_id == \\\"Default\\\":\\n\\t\\t\\t\\\n          subnet_id = \\\"\\\"\\n\\t\\t\\tfor subnet in ec2.describe_subnets(Filters=[{'Name':\\\n          \\ 'vpc-id', 'Values': [vpc_id]}]).get('Subnets'):\\n\\t\\t\\t\\tif subnet.get('DefaultForAz',\\\n          \\ False) and subnet['VpcId'] == vpc_id:\\n\\t\\t\\t\\t\\tsubnet_id = subnet['SubnetId']\\n\\\n          \\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif len(subnet_id) == 0:\\n\\t\\t\\t\\traise Exception(\\\"\\\n          Unable to find default subnet for vpc\\\")\\n\\t\\tdata[\\\"SubnetId\\\"] = subnet_id\\n\\\n          \\n\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, data, event.get(\\\"\\\n          PhysicalResourceId\\\", None))\\n\\texcept Exception as e:\\n\\t\\tprint str(e)\\n\\\n          \\t\\ttraceback.print_exc()\\n\\t\\tcfnresponse.send(event, context, cfnresponse.FAILED,\\\n          \\ {}, event.get(\\\"PhysicalResourceId\\\", None))\\n\\n\\ndef handler_delete(event,\\\n          \\ context):\\n\\t# Nothing to do... this is a informational lambda and no\\\n          \\ resource is created.\\n\\tcfnresponse.send(event, context, cfnresponse.SUCCESS,\\\n          \\ {}, event[\\\"PhysicalResourceId\\\"])\\n\\n\\ndef handler(event, context):\\n\\\n          \\tif event[\\\"RequestType\\\"] in [\\\"Create\\\", \\\"Update\\\"]:\\n\\t\\thandler_subnet_info(event,\\\n          \\ context)\\n\\telif event[\\\"RequestType\\\"] in [\\\"Delete\\\"]:\\n\\t\\thandler_delete(event,\\\n          \\ context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python2.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n  CollectSubnetInformation:\n    Properties:\n      ServiceToken:\n        Fn::GetAtt: [CollectSubnetInfoLambda, Arn]\n      SubnetId: {Ref: SubnetId}\n      VpcId:\n        Fn::GetAtt: [CollectInformation, VpcId]\n    Type: Custom::CollectSubnetInformation\n  CreateInstance:\n    DeletionPolicy: Retain\n    Properties:\n      IamInstanceProfile: {Ref: RoleName}\n      ImageId: {Ref: AmiId}\n      InstanceType: {Ref: InstanceType}\n      KeyName:\n        Fn::If:\n        - KeyNameSpecified\n        - {Ref: KeyName}\n        - {Ref: 'AWS::NoValue'}\n      SecurityGroupIds:\n      - Fn::GetAtt: [CreateSecurityGroup, SecurityGroupId]\n      SubnetId:\n        Fn::GetAtt: [CollectSubnetInformation, SubnetId]\n      UserData:\n        Fn::GetAtt: [CollectInformation, UserData]\n    Type: AWS::EC2::Instance\n  CreateInstanceRole:\n    Properties:\n      InstanceProfileName: {Ref: RoleName}\n      ServiceToken:\n        Fn::GetAtt: [InstanceProfileLambda, Arn]\n    Type: Custom::InstanceProfile\n  CreateSecurityGroup:\n    Properties:\n      AccessCidr: {Ref: RemoteAccessCidr}\n      GroupName: {Ref: GroupName}\n      Platform:\n        Fn::GetAtt: [CollectInformation, Platform]\n      ServiceToken:\n        Fn::GetAtt: [SecurityGroupLambda, Arn]\n      VpcId:\n        Fn::GetAtt: [CollectInformation, VpcId]\n    Type: Custom::SecurityGroup\n  InstanceProfileLambda:\n    Properties:\n      Code: {ZipFile: \"import json\\nimport boto3\\n\\nimport cfnresponse\\n\\nPOLICY_ARNS\\\n          \\ = ['arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM']\\n\\n\\ndef\\\n          \\ handler_create(event, context):\\n\\tname = event[\\\"ResourceProperties\\\"\\\n          ].get(\\\"InstanceProfileName\\\", None)\\n\\tiam = boto3.client('iam')\\n\\ttry:\\n\\\n          \\t\\tif name is None:\\n\\t\\t\\traise Exception(\\\"InstanceProfileName must be\\\n          \\ defined\\\")\\n\\n\\t\\ttry:\\n\\t\\t\\tif iam.get_instance_profile(InstanceProfileName=name):\\n\\\n          \\t\\t\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, {}, \\\"existing:{}\\\"\\\n          .format(name))\\n\\t\\t\\t\\treturn\\n\\t\\texcept iam.exceptions.NoSuchEntityException:\\n\\\n          \\t\\t\\tpass\\n\\n\\t\\tprint(\\\"Role \\\" + name + \\\" does not exist. Creating\\\"\\\n          )\\n\\n\\t\\tmy_access_control_policy = {\\n\\t\\t\\t\\\"Version\\\": \\\"2012-10-17\\\"\\\n          ,\\n\\t\\t\\t\\\"Statement\\\": [\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\\"Effect\\\": \\\"Allow\\\",\\n\\\n          \\t\\t\\t\\t\\t\\\"Principal\\\": {\\n\\t\\t\\t\\t\\t\\t\\\"Service\\\": [\\n\\t\\t\\t\\t\\t\\t\\t\\\"\\\n          ssm.amazonaws.com\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\\"ec2.amazonaws.com\\\"\\n\\t\\t\\t\\t\\t\\t\\\n          ]\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\\"Action\\\": \\\"sts:AssumeRole\\\"\\n\\t\\t\\t\\t}\\n\\t\\\n          \\t\\t]\\n\\t\\t}\\n\\n\\t\\t# Get the desired role\\n\\t\\tiam.create_role(\\n\\t\\t\\t\\\n          RoleName=name,\\n\\t\\t\\tDescription='Role created from Lambda',\\n\\t\\t\\tAssumeRolePolicyDocument=json.dumps(my_access_control_policy))\\n\\\n          \\n\\t\\tfor policy in POLICY_ARNS:\\n\\t\\t\\tiam.attach_role_policy(RoleName=name,\\\n          \\ PolicyArn=policy)\\n\\t\\tprint(\\\"Role \\\" + name + \\\" created\\\")\\n\\n\\t\\t\\\n          # create the instance profile\\n\\t\\tiam.create_instance_profile(InstanceProfileName=name)\\n\\\n          \\n\\t\\tiam.add_role_to_instance_profile(InstanceProfileName=name, RoleName=name)\\n\\\n          \\t\\tprint(\\\"Instance profile \\\" + name + \\\" created\\\")\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.SUCCESS, {}, \\\"created:{}\\\".format(name))\\n\\texcept\\\n          \\ Exception as e:\\n\\t\\tprint str(e)\\n\\t\\tdelete_all(iam, name)\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.FAILED, {}, \\\"created:{}\\\".format(name))\\n\\n\\ndef\\\n          \\ handler_update(event, context):\\n\\tcfnresponse.send(event, context, cfnresponse.FAILED,\\\n          \\ {}, event[\\\"PhysicalResourceId\\\"])\\n\\n\\ndef handler_delete(event, context):\\n\\\n          \\tcf = boto3.client(\\\"cloudformation\\\")\\n\\tstack = cf.describe_stacks(StackName=event[\\\"\\\n          StackId\\\"])[\\\"Stacks\\\"][0]\\n\\tresource_id = event[\\\"PhysicalResourceId\\\"\\\n          ]\\n\\tif resource_id.startswith(\\\"existing:\\\") or stack[\\\"StackStatus\\\"]\\\n          \\ == \\\"DELETE_IN_PROGRESS\\\":\\n\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS,\\\n          \\ {}, event[\\\"PhysicalResourceId\\\"])\\n\\t\\treturn\\n\\t_, name = event[\\\"PhysicalResourceId\\\"\\\n          ].split(\\\":\\\")\\n\\n\\ttry:\\n\\t\\tdelete_all(boto3.client('iam'), name)\\n\\t\\t\\\n          cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, resource_id)\\n\\\n          \\texcept Exception as e:\\n\\t\\tprint str(e)\\n\\t\\tdelete_all(boto3.client('iam'),\\\n          \\ name)\\n\\t\\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, resource_id)\\n\\\n          \\n\\ndef delete_all(iam, name):\\n\\tclean_policies(iam, name)\\n\\tclean_instance_profile(iam,\\\n          \\ name)\\n\\tdelete_instance_profile(iam, name)\\n\\tdelete_role(iam, name)\\n\\\n          \\n\\ndef clean_policies(iam, name):\\n\\ttry:\\n\\t\\tattached = iam.list_attached_role_policies(RoleName=name)\\n\\\n          \\t\\tfor policy in attached[\\\"AttachedPolicies\\\"]:\\n\\t\\t\\tiam.detach_role_policy(RoleName=name,\\\n          \\ PolicyArn=policy[\\\"PolicyArn\\\"])\\n\\texcept Exception as e:\\n\\t\\tprint\\\n          \\ str(e)\\n\\n\\ndef clean_instance_profile(iam, name):\\n\\ttry:\\n\\t\\tinstance_profile\\\n          \\ = iam.get_instance_profile(InstanceProfileName=name)\\n\\t\\tfor role in\\\n          \\ instance_profile[\\\"InstanceProfile\\\"].get(\\\"Roles\\\", []):\\n\\t\\t\\tiam.remove_role_from_instance_profile(\\n\\\n          \\t\\t\\t\\tInstanceProfileName=name,\\n\\t\\t\\t\\tRoleName=role[\\\"RoleName\\\"]\\n\\\n          \\t\\t\\t)\\n\\texcept Exception as e:\\n\\t\\tprint str(e)\\n\\n\\ndef delete_instance_profile(iam,\\\n          \\ name):\\n\\ttry:\\n\\t\\tiam.delete_instance_profile(InstanceProfileName=name)\\n\\\n          \\texcept Exception as e:\\n\\t\\tprint str(e)\\n\\n\\ndef delete_role(iam, name):\\n\\\n          \\ttry:\\n\\t\\tiam.delete_role(RoleName=name)\\n\\texcept Exception as e:\\n\\t\\\n          \\tprint str(e)\\n\\n\\ndef handler(event, context):\\n\\tif event[\\\"RequestType\\\"\\\n          ] == \\\"Create\\\":\\n\\t\\thandler_create(event, context)\\n\\telif event[\\\"RequestType\\\"\\\n          ] == \\\"Update\\\":\\n\\t\\thandler_update(event, context)\\n\\telse:\\n\\t\\thandler_delete(event,\\\n          \\ context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python2.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n  LambdaLogPolicy:\n    Condition: IsVerboseAndLambdaRoleNotSpecified\n    Properties:\n      PolicyDocument:\n        Statement:\n          Action: ['log:CreateLogStream', 'log:PutLogEvents', 'log:CreateLogGroup']\n          Effect: Allow\n          Resource: {'Fn::Sub': 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'}\n        Version: '2012-10-17'\n      PolicyName: lambda-log-access\n      Roles:\n      - {Ref: LambdaRole}\n    Type: AWS::IAM::Policy\n  LambdaRole:\n    Condition: LambdaAssumeRoleNotSpecified\n    Properties:\n      AssumeRolePolicyDocument:\n        Statement:\n        - Action: ['sts:AssumeRole']\n          Effect: Allow\n          Principal:\n            Service: [lambda.amazonaws.com]\n        Version: '2012-10-17'\n      ManagedPolicyArns: ['arn:aws:iam::aws:policy/AWSCloudFormationReadOnlyAccess',\n        'arn:aws:iam::aws:policy/AWSLambdaExecute', 'arn:aws:iam::aws:policy/AmazonSSMFullAccess',\n        'arn:aws:iam::aws:policy/IAMFullAccess', 'arn:aws:iam::aws:policy/AmazonEC2FullAccess']\n      Path: /\n    Type: AWS::IAM::Role\n  SecurityGroupLambda:\n    Properties:\n      Code: {ZipFile: \"import boto3\\nimport traceback\\nimport cfnresponse\\n\\n\\ndef\\\n          \\ find_security_groups(ec2, vpc_id, group_name):\\n\\tsecurity_groups = ec2.describe_security_groups(Filters=[\\n\\\n          \\t\\t{\\\"Name\\\": \\\"group-name\\\", \\\"Values\\\": [group_name]},\\n\\t\\t{\\\"Name\\\"\\\n          : \\\"vpc-id\\\", \\\"Values\\\": [vpc_id]}\\n\\t])[\\\"SecurityGroups\\\"]\\n\\tfor security_group\\\n          \\ in security_groups:\\n\\t\\tif security_group[\\\"GroupName\\\"] == group_name\\\n          \\ and security_group[\\\"VpcId\\\"] == vpc_id:\\n\\t\\t\\treturn security_group\\n\\\n          \\treturn None\\n\\n\\ndef handler_create(event, context):\\n\\tgroup_name = event[\\\"\\\n          ResourceProperties\\\"].get(\\\"GroupName\\\", None)\\n\\tcidr = event[\\\"ResourceProperties\\\"\\\n          ].get(\\\"AccessCidr\\\", \\\"\\\")\\n\\tvpc_id = event[\\\"ResourceProperties\\\"].get(\\\"\\\n          VpcId\\\", None)\\n\\tplatform = event[\\\"ResourceProperties\\\"].get(\\\"Platform\\\"\\\n          , None)\\n\\n\\tec2 = boto3.client('ec2')\\n\\tsecurity_group_id = None\\n\\ttry:\\n\\\n          \\t\\tsecurity_group = find_security_groups(ec2, vpc_id, group_name)\\n\\t\\t\\\n          if security_group is not None:\\n\\t\\t\\tdata = {\\\"SecurityGroupId\\\": security_group[\\\"\\\n          GroupId\\\"]}\\n\\t\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS,\\\n          \\ data, \\\"existing:{}:{}\\\".format(vpc_id, group_name))\\n\\t\\t\\treturn\\n\\n\\\n          \\t\\tresponse = ec2.create_security_group(\\n\\t\\t\\tGroupName=group_name,\\n\\\n          \\t\\t\\tDescription='Security Group created from Lambda',\\n\\t\\t\\tVpcId=vpc_id)\\n\\\n          \\t\\tsecurity_group_id = response['GroupId']\\n\\n\\t\\tif len(cidr) > 0:\\n\\t\\\n          \\t\\tif platform == 'windows':\\n\\t\\t\\t\\tdata = ec2.authorize_security_group_ingress(\\n\\\n          \\t\\t\\t\\t\\tGroupId=security_group_id,\\n\\t\\t\\t\\t\\tIpPermissions=[\\n\\t\\t\\t\\t\\\n          \\t\\t{'IpProtocol': 'tcp',\\n\\t\\t\\t\\t\\t\\t 'FromPort': 3389,\\n\\t\\t\\t\\t\\t\\t\\\n          \\ 'ToPort': 3389,\\n\\t\\t\\t\\t\\t\\t 'IpRanges': [{'CidrIp': cidr}]}\\n\\t\\t\\t\\t\\\n          \\t])\\n\\t\\t\\t\\tprint('Ingress Successfully Set %s' % data)\\n\\t\\t\\telse:\\n\\\n          \\t\\t\\t\\tdata = ec2.authorize_security_group_ingress(\\n\\t\\t\\t\\t\\tGroupId=security_group_id,\\n\\\n          \\t\\t\\t\\t\\tIpPermissions=[\\n\\t\\t\\t\\t\\t\\t{'IpProtocol': 'tcp',\\n\\t\\t\\t\\t\\t\\\n          \\t 'FromPort': 22,\\n\\t\\t\\t\\t\\t\\t 'ToPort': 22,\\n\\t\\t\\t\\t\\t\\t 'IpRanges':\\\n          \\ [{'CidrIp': cidr}]}\\n\\t\\t\\t\\t\\t])\\n\\t\\t\\t\\tprint('Ingress Successfully\\\n          \\ Set %s' % data)\\n\\n\\t\\tdata = {\\\"SecurityGroupId\\\": security_group_id}\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, data, \\\"created:{}:{}\\\"\\\n          .format(vpc_id, security_group_id))\\n\\texcept Exception as e:\\n\\t\\tprint\\\n          \\ str(e)\\n\\t\\ttraceback.print_exc()\\n\\t\\tdelete_all(ec2, vpc_id, security_group_id)\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, \\\"created:{}:{}\\\"\\\n          .format(vpc_id, security_group_id))\\n\\n\\ndef handler_update(event, context):\\n\\\n          \\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, event[\\\"PhysicalResourceId\\\"\\\n          ])\\n\\n\\ndef handler_delete(event, context):\\n\\tcf = boto3.client(\\\"cloudformation\\\"\\\n          )\\n\\tstack = cf.describe_stacks(StackName=event[\\\"StackId\\\"])[\\\"Stacks\\\"\\\n          ][0]\\n\\tresource_id = event[\\\"PhysicalResourceId\\\"]\\n\\tif resource_id.startswith(\\\"\\\n          existing:\\\") or stack[\\\"StackStatus\\\"] == \\\"DELETE_IN_PROGRESS\\\":\\n\\t\\t\\\n          cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event[\\\"PhysicalResourceId\\\"\\\n          ])\\n\\t\\treturn\\n\\t_, vpc_id, group_id = event[\\\"PhysicalResourceId\\\"].split(\\\"\\\n          :\\\")\\n\\n\\ttry:\\n\\t\\tdelete_all(boto3.client('ec2'), vpc_id, group_id)\\n\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, {}, resource_id)\\n\\\n          \\texcept Exception as e:\\n\\t\\tprint str(e)\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.FAILED, {}, resource_id)\\n\\n\\ndef delete_all(ec2,\\\n          \\ vpc_id, group_id):\\n\\tif group_id is not None:\\n\\t\\ttry:\\n\\t\\t\\tec2.delete_security_group(GroupId=group_id)\\n\\\n          \\t\\texcept Exception as e:\\n\\t\\t\\tstr(e)\\n\\n\\ndef handler(event, context):\\n\\\n          \\tif event[\\\"RequestType\\\"] == \\\"Create\\\":\\n\\t\\thandler_create(event, context)\\n\\\n          \\telif event[\\\"RequestType\\\"] == \\\"Update\\\":\\n\\t\\thandler_update(event,\\\n          \\ context)\\n\\telse:\\n\\t\\thandler_delete(event, context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python2.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n", 
        "TimeoutInMinutes": 30
      }
    }, 
    {
      "name": "deleteManagedInstanceStack", 
      "action": "aws:deleteStack", 
      "maxAttempts": 1, 
      "onFailure": "Abort", 
      "inputs": {
        "StackName": "{{StackName}}"
      }
    }
  ]
}
